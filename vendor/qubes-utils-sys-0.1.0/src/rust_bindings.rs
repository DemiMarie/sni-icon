/* automatically generated by rust-bindgen 0.68.1 */

#[doc = " A counted buffer used by some functions in this library.\n Equivalent to Rust's &[T]."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QubesSlice {
    #[doc = " Pointer to the data"]
    pub pointer: *const u8,
    #[doc = " Length of the data"]
    pub length: usize,
}
#[test]
fn bindgen_test_layout_QubesSlice() {
    const UNINIT: ::std::mem::MaybeUninit<QubesSlice> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<QubesSlice>(),
        16usize,
        concat!("Size of: ", stringify!(QubesSlice))
    );
    assert_eq!(
        ::std::mem::align_of::<QubesSlice>(),
        8usize,
        concat!("Alignment of ", stringify!(QubesSlice))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pointer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(QubesSlice),
            "::",
            stringify!(pointer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(QubesSlice),
            "::",
            stringify!(length)
        )
    );
}
extern "C" {
    #[doc = " Validate that a string is a valid path and will not result in\n directory traversal if used as such.  Characters that are unsafe for\n filenames are also rejected, including invalid UTF-8 sequences and\n all control characters.  The input must be NUL-terminated.\n\n Returns true on success and false on failure."]
    pub fn qubes_pure_validate_file_name(untrusted_filename: *const u8) -> bool;
}
extern "C" {
    #[doc = " Validate that `untrusted_name` is a valid symbolic link name\n and that creating a symbolic link with that name and target\n `untrusted_target` is also safe.  Characters that are unsafe for\n filenames are also rejected, including invalid UTF-8\n sequences and all control characters.  The input must be\n NUL-terminated.\n\n Returns true on success and false on failure."]
    pub fn qubes_pure_validate_symbolic_link(
        untrusted_name: *const u8,
        untrusted_target: *const u8,
    ) -> bool;
}
extern "C" {
    #[doc = " Validate that `code_point` is safe to display.  To be considered safe to\n display, a code point must be valid and not be a control character.\n Additionally, the code point must not be a character that is complex\n to render and thus significantly increases the attack surface of text\n rendering libraries such as Fribidi, Harfbuzz, or Pango.  The set of\n characters that are considered complex to render is implementation\n dependent and may change in future versions of this library.  Currenty,\n it includes the following:\n\n - Characters that have a character direction property other than\n   WHITE_SPACE_NEUTRAL, OTHRE_NEUTRAL, EUROPEAN_NUMBER_TERMINATOR,\n   EUROPEAN_NUMBER_SEPARATOR, COMMON_NUMBER_SEPARATOR, or LEFT_TO_RIGHT.\n\n - Characters that are part of scripts that are not recommended for use\n   in identifiers.  This includes limited-use scripts.\n\n - Characters with scripts that are not INHERITED, CYRILLIC, GREEK, LATIN,\n   BRAILLE, SIMPLIFIED_HAN, TRADITIONAL_HAN, HAN, HAN_WITH_BOPOMOFO, JAMO,\n   HANGUL, BOPOMOFO, KATAKANA_OR_HIRAGANA, HIRIGANA, KATAKANA, JAPANESE,\n   KOREAN, or COMMON.\n\n This is implemented as an allowlist, not as a blocklist, so unknown code\n points are considered _unsafe_ for display.\n\n @param code_point The code point to check for being safe to display.\n\n This API does _not_ require that @p code_point is a valid Unicode code point.\n Invalid code points are simply considered to be unsafe for display.\n Therefore, this function has defined behavior for _all_ inputs."]
    pub fn qubes_pure_code_point_safe_for_display(code_point: u32) -> bool;
}
extern "C" {
    #[doc = " Validate that `untrusted_str` is safe to display.  To be considered safe to\n display, a string must be valid UTF-8 and contain no control characters\n except perhaps newline.  The string must also contain no characters that\n are considered unsafe for display by qubes_pure_code_point_safe_for_display()."]
    pub fn qubes_pure_string_safe_for_display(
        untrusted_str: *const ::std::os::raw::c_char,
        line_length: usize,
    ) -> bool;
}
#[doc = " Qube name is OK (not an error)."]
pub const QubeNameValidationError_QUBE_NAME_OK: QubeNameValidationError = 0;
#[doc = " Name is empty."]
pub const QubeNameValidationError_QUBE_NAME_EMPTY: QubeNameValidationError = -1;
#[doc = " Name is more than QUBES_PURE_MAX_QUBE_NAME_LEN bytes."]
pub const QubeNameValidationError_QUBE_NAME_TOO_LONG: QubeNameValidationError = -2;
#[doc = " Name does not start with an ASCII letter."]
pub const QubeNameValidationError_QUBE_NAME_INVALID_FIRST_CHARACTER: QubeNameValidationError = -3;
#[doc = " Invalid character in name."]
pub const QubeNameValidationError_QUBE_NAME_INVALID_SUBSEQUENT_CHARACTER: QubeNameValidationError =
    -4;
#[doc = " Name is `none`, `default`, `Domain-0`, or ends in `-dm`.\n These names are reserved."]
pub const QubeNameValidationError_QUBE_NAME_RESERVED: QubeNameValidationError = -6;
#[doc = " Errors that can occur when validating a qube name."]
pub type QubeNameValidationError = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Validate that `untrusted_str` is a valid qube name.  A valid qube name\n must:\n\n - Have a length between 1 and 31 bytes (inclusive).\n - Consist only of characters matching the glob pattern [A-Za-z0-9_.-].\n - Begin with an uppercase or lowercase ASCII letter.\n - Not end with the 3 bytes `-dm`, to avoid confusing with device-model\n   stubdomains.\n - Not be `none` or `default`, which are reserved for the admin API.\n - Not be `Domain-0`, which is used by libvirt and libxl to refer to dom0.\n\n Returns QUBE_NAME_OK (0) on success and something else on failure."]
    pub fn qubes_pure_is_valid_qube_name(untrusted_str: QubesSlice) -> QubeNameValidationError;
}
